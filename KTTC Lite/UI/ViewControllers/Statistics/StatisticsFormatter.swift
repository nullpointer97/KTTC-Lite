//
//  StatisticsFormatter.swift
//  KTTC Lite
//
//  Created by –Ø—Ä–æ—Å–ª–∞–≤ –°—Ç—Ä–µ–ª—å–Ω–∏–∫–æ–≤ on 26.10.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import UIKit

struct NeedCalculateData {
    var battles: Double = 0
    var averageLevel: Double = 0
    var wn6: WN6 = 0
    var wn7: WN7 = 0
    var wn8: WN8 = 0
    var eff: EFF = 0
    var xwn8: WN8 = 0
    
    var xp: Double = 0
    var damage: Double = 0
    var spotted: Double = 0
    var frags: Double = 0
    var wins: Double = 0
    var maxFrags: Double = 0
    var def: Double = 0
    var cap: Double = 0
    
    var assist: Double = 0
    var hits: Double = 0
    
    var maxDamage: Double = 0
    
    var avgDamage: Double {
        (damage / battles).round(to: 2)
    }
    
    var avgSpotted: Double {
        (spotted / battles).round(to: 2)
    }
    
    var avgFrags: Double {
        (frags / battles).round(to: 2)
    }
    
    var avgDef: Double {
        (def / battles).round(to: 2)
    }
    
    var avgXP: Double {
        (xp / battles).round(to: 2)
    }
    
    var avgCap: Double {
        (cap / battles).round(to: 2)
    }

    var winrate: Double {
        (wins / (battles / 100)).round(to: 2)
    }
    
    mutating func erase() {
        battles = 0
        averageLevel = 0
        wn8 = 0
        wn7 = 0
        wn6 = 0
        eff = 0
        xp = 0
        damage = 0
        spotted = 0
        frags = 0
        wins = 0
        maxDamage = 0
        maxFrags = 0
        def = 0
        cap = 0
        assist = 0
        hits = 0
    }
}

struct DataValue: Hashable {
    var key: String
    var value: Any
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(key)
    }
    
    static func == (lhs: DataValue, rhs: DataValue) -> Bool {
        return lhs.key == rhs.key
    }
}

enum Section {
    case warning
    case ratings
    case firstDivider
    case winrate
    case secondDivider
    case shoots
    case thirdDivider
    case frags
    case fourtDivider
    case good
    case average
    case bad
}

enum Item: Hashable {
    case description(String)
    case value((String, Double))
    
    func hash(into hasher: inout Hasher) {
        switch self {
        case .description(let d):
            hasher.combine(d)
        case .value((let k, let v)):
            hasher.combine(k)
            hasher.combine(v)
        }
    }

    static func == (lhs: Item, rhs: Item) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

typealias DataSource = UICollectionViewDiffableDataSource<Section, Item>
typealias Snapshot = NSDiffableDataSourceSnapshot<Section, Item>

struct TankModel {
    var name: String
    var level: String
    var id: Int
}

final class StatisticsFormatter {
    weak var presenter: StatisticsPresenterInterface?
    var needCalculateData: NeedCalculateData = NeedCalculateData()
}

// MARK: - Extensions -

extension StatisticsFormatter: StatisticsFormatterInterface {
    func makeDataSource(collectionView: UICollectionView) -> DataSource {
        let dataSource = DataSource(collectionView: collectionView) { [weak self] collectionView, indexPath, object in
            guard let self = self else { abort() }
            guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "ParameterCell", for: indexPath) as? ParameterCell else { abort() }
            
            let section = self.presenter?.view.snapshot.sectionIdentifiers[indexPath.section]
            
            switch object {
            case .description(let d):
                switch section {
                case .warning:
                    cell.backgroundColor = .systemBackground
                    cell.parameterLabel.textColor = .secondaryLabel
                    cell.parameterLabel.numberOfLines = 2
                    cell.parameterLabel.textAlignment = .center
                    cell.parameterLabel.text = d
                    cell.parameterLabel.font = .systemFont(ofSize: 11, weight: .light)
                case .bad, .good, .average:
                    cell.backgroundColor = .systemBackground
                    cell.parameterLabel.numberOfLines = 1
                    cell.parameterLabel.textAlignment = .center
                    cell.parameterLabel.text = d
                    cell.parameterLabel.font = .systemFont(ofSize: 12, weight: .bold)

                    switch d {
                    case "–£–Ω–∏–∫—É–º":
                        cell.parameterLabel.textColor = .color(from: 0xb14cc2)
                    case "–í–µ–ª–∏–∫–æ–ª–µ–ø–Ω—ã–π –∏–≥—Ä–æ–∫":
                        cell.parameterLabel.textColor = .color(from: 0x06a7a7)
                    case "–•–æ—Ä–æ—à–∏–π –∏–≥—Ä–æ–∫":
                        cell.parameterLabel.textColor = .color(from: 0x59e500)
                    case "–°—Ä–µ–¥–Ω–∏–π –∏–≥—Ä–æ–∫":
                        cell.parameterLabel.textColor = .color(from: 0xffe704)
                    case "–ò–≥—Ä–æ–∫ –Ω–∏–∂–µ —Å—Ä–µ–¥–Ω–µ–≥–æ":
                        cell.parameterLabel.textColor = .color(from: 0xff8e00)
                    case "–ü–ª–æ—Ö–æ–π –∏–≥—Ä–æ–∫":
                        cell.parameterLabel.textColor = .color(from: 0xff2901)
                    default:
                        cell.parameterLabel.textColor = .label
                    }
                default:
                    cell.backgroundColor = .systemBackground
                    cell.parameterLabel.numberOfLines = 1
                    cell.parameterLabel.textAlignment = .natural
                    cell.parameterLabel.text = d
                    cell.parameterLabel.font = .systemFont(ofSize: 13, weight: .medium)
                    cell.parameterLabel.textColor = .label
                }
            case .value((let key, let value)):
                let value = value.checkToNaN()
                
                cell.parameterLabel.textAlignment = .natural
                cell.parameterLabel.numberOfLines = 1
                cell.parameterLabel.text = "\(value)"
                cell.parameterLabel.font = .systemFont(ofSize: 13, weight: .medium)
                
                if indexPath.item % 2 != 0 && indexPath.section < 8 {
                    switch key {
                    case "avgDamage":
                        cell.parameterLabel.textColor = .xwmColor(from: .damage, with: value)
                    case "wn6":
                        cell.parameterLabel.textColor = .xwmColor(from: .wn6, with: value)
                        cell.parameterLabel.text = "\(value.round(to: 2))"
                    case "wn7":
                        cell.parameterLabel.textColor = .xwmColor(from: .wn7, with: value)
                        cell.parameterLabel.text = "\(value.round(to: 2))"
                    case "wn8":
                        cell.parameterLabel.textColor = .xwmColor(from: .wn8, with: value)
                        cell.parameterLabel.text = "\(value.round(to: 2))"
                    case "xwn8":
                        cell.parameterLabel.textColor = .xwmColor(from: .xwn8, with: value)
                        cell.parameterLabel.text = "\(value.round(to: 2))"
                        self.presenter?.view.setXVMTitle(withColor: .xwmColor(from: .xwn8, with: value))
                    case "winrate":
                        cell.parameterLabel.textColor = .xwmColor(from: .winrate, with: value)
                        cell.parameterLabel.text = "\(value)%"
                    case "battles":
                        cell.parameterLabel.textColor = .label
                        cell.parameterLabel.text = "\(value.int)"
                    case "maxFrags":
                        cell.parameterLabel.textColor = .xwmColor(from: .frags, with: value)
                        cell.parameterLabel.text = "\(value.int)"
                    case "eff":
                        cell.parameterLabel.textColor = .xwmColor(from: .eff, with: value)
                        cell.parameterLabel.text = "\(value.round(to: 2))"
                    case "spotted", "frags":
                        cell.parameterLabel.textColor = .label
                        cell.parameterLabel.text = "\(value.int)"
                    default:
                        cell.parameterLabel.textColor = .label
                    }
                }
            }

            switch section {
            case .firstDivider, .secondDivider, .thirdDivider, .fourtDivider:
                cell.parameterLabel.textAlignment = .natural
                cell.parameterLabel.numberOfLines = 1
                cell.backgroundColor = .dividerColor
                cell.parameterLabel.text = nil
            default:
                cell.backgroundColor = .systemBackground
            }
            
            return cell
        }
        
        return dataSource
    }
    
    func makeSnapshot() -> Snapshot {
        return Snapshot()
    }
    
    func finish() {
        DispatchQueue.main.sync { [weak self] in
            self?.presenter?.view.stopLoading()
            self?.updateDataSource()
        }
    }
    
    private func updateDataSource() {
        presenter?.view.snapshot.appendSections([.warning, .winrate, .firstDivider, .ratings, .secondDivider, .frags, .thirdDivider, .shoots, .fourtDivider, .good, .average, .bad])
        presenter?.view.dataSource.apply(presenter?.view.snapshot ?? makeSnapshot())
        
        presenter?.view.snapshot.appendItems([.description("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ –∑–∞–Ω–∏–º–∞–µ—Ç –Ω–µ–∫–æ—Ço—Ä–æ–µ –≤—Ä–µ–º—è")], toSection: .warning)
        
        presenter?.view.snapshot.appendItems([.description("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–æ—ë–≤"), .value(("battles", needCalculateData.battles))], toSection: .winrate)
        presenter?.view.snapshot.appendItems([.description("–ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–±–µ–¥"), .value(("winrate", needCalculateData.winrate))], toSection: .winrate)
        presenter?.view.snapshot.appendItems([.description("–°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å"), .value(("averageLevel", needCalculateData.averageLevel.round(to: 1)))], toSection: .winrate)
        
        presenter?.view.snapshot.appendItems([.value(("d1", 0))], toSection: .firstDivider)

        presenter?.view.snapshot.appendItems([.description("–†–µ–π—Ç–∏–Ω–≥ WN6"), .value(("wn6", needCalculateData.wn6))], toSection: .ratings)
        presenter?.view.snapshot.appendItems([.description("–†–µ–π—Ç–∏–Ω–≥ WN7"), .value(("wn7", needCalculateData.wn7))], toSection: .ratings)
        presenter?.view.snapshot.appendItems([.description("–†–µ–π—Ç–∏–Ω–≥ WN8"), .value(("wn8", needCalculateData.wn8))], toSection: .ratings)
        presenter?.view.snapshot.appendItems([.description("–†–µ–π—Ç–∏–Ω–≥ –†–≠"), .value(("eff", needCalculateData.eff))], toSection: .ratings)
        presenter?.view.snapshot.appendItems([.description("–†–µ–π—Ç–∏–Ω–≥ XVM"), .value(("xwn8", needCalculateData.xwn8))], toSection: .ratings)

        presenter?.view.snapshot.appendItems([.value(("d2", 0))], toSection: .secondDivider)

        presenter?.view.snapshot.appendItems([.description("–°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–Ω"), .value(("avgDamage", needCalculateData.avgDamage))], toSection: .frags)
        presenter?.view.snapshot.appendItems([.description("–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —É–Ω–∏—á—Ç–æ–∂–∏–ª"), .value(("maxFrags", needCalculateData.maxFrags))], toSection: .frags)
        if !(presenter?.view.isBlitz ?? false) {
            presenter?.view.snapshot.appendItems([.description("–ê—Å—Å–∏—Å—Ç —É—Ä–æ–Ω"), .value(("assist", needCalculateData.assist))], toSection: .frags)
            presenter?.view.snapshot.appendItems([.description("–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–Ω"), .value(("maxDamage", needCalculateData.maxDamage))], toSection: .frags)
            presenter?.view.snapshot.appendItems([.description("–ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–ø–∞–¥–∞–Ω–∏–π"), .value(("hits", needCalculateData.hits))], toSection: .frags)
        }

        presenter?.view.snapshot.appendItems([.value(("d3", 0))], toSection: .thirdDivider)

        presenter?.view.snapshot.appendItems([.description("–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –≤—Ä–∞–≥–æ–≤ (–≤—Å–µ–≥–æ)"), .value(("spotted", needCalculateData.spotted))], toSection: .shoots)
        presenter?.view.snapshot.appendItems([.description("–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –≤—Ä–∞–≥–æ–≤ (–≤ c—Ä–µ–¥–Ω–µ–º)"), .value(("avgSpotted", needCalculateData.avgSpotted))], toSection: .shoots)
        presenter?.view.snapshot.appendItems([.description("–£–Ω–∏—á—Ç–æ–∂–µ–Ω–æ –≤—Ä–∞–≥–æ–≤ (–≤—Å–µ–≥–æ)"), .value(("frags", needCalculateData.frags))], toSection: .shoots)
        presenter?.view.snapshot.appendItems([.description("–£–Ω–∏—á—Ç–æ–∂–µ–Ω–æ –≤—Ä–∞–≥–æ–≤ (–≤ c—Ä–µ–¥–Ω–µ–º)"), .value(("avgFrags", needCalculateData.avgFrags))], toSection: .shoots)

        presenter?.view.snapshot.appendItems([.value(("d4", 0))], toSection: .fourtDivider)

        presenter?.view.snapshot.appendItems([.description("–£–Ω–∏–∫—É–º"), .description("–°—Ä–µ–¥–Ω–∏–π –∏–≥—Ä–æ–∫")], toSection: .good)
        presenter?.view.snapshot.appendItems([.description("–í–µ–ª–∏–∫–æ–ª–µ–ø–Ω—ã–π –∏–≥—Ä–æ–∫"), .description("–ò–≥—Ä–æ–∫ –Ω–∏–∂–µ —Å—Ä–µ–¥–Ω–µ–≥–æ")], toSection: .average)
        presenter?.view.snapshot.appendItems([.description("–•–æ—Ä–æ—à–∏–π –∏–≥—Ä–æ–∫"), .description("–ü–ª–æ—Ö–æ–π –∏–≥—Ä–æ–∫")], toSection: .bad)
        
        presenter?.view.dataSource.apply(presenter?.view.snapshot ?? makeSnapshot())
    }
}
